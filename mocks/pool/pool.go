// Code generated by mockery v2.30.1. DO NOT EDIT.

package mockpool

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	pool "github.com/tarantool/go-tarantool/v2/pool"

	tarantool "github.com/tarantool/go-tarantool/v2"

	time "time"
)

// Pool is an autogenerated mock type for the Pool type
type Pool struct {
	mock.Mock
}

// Add provides a mock function with given fields: ctx, instance
func (_m *Pool) Add(ctx context.Context, instance pool.Instance) error {
	ret := _m.Called(ctx, instance)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, pool.Instance) error); ok {
		r0 = rf(ctx, instance)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Call provides a mock function with given fields: functionName, args, mode
func (_m *Pool) Call(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	ret := _m.Called(functionName, args, mode)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) ([]interface{}, error)); ok {
		return rf(functionName, args, mode)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) []interface{}); ok {
		r0 = rf(functionName, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, pool.Mode) error); ok {
		r1 = rf(functionName, args, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Call16 provides a mock function with given fields: functionName, args, mode
func (_m *Pool) Call16(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	ret := _m.Called(functionName, args, mode)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) ([]interface{}, error)); ok {
		return rf(functionName, args, mode)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) []interface{}); ok {
		r0 = rf(functionName, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, pool.Mode) error); ok {
		r1 = rf(functionName, args, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Call16Async provides a mock function with given fields: functionName, args, mode
func (_m *Pool) Call16Async(functionName string, args interface{}, mode pool.Mode) *tarantool.Future {
	ret := _m.Called(functionName, args, mode)

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) *tarantool.Future); ok {
		r0 = rf(functionName, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// Call16Typed provides a mock function with given fields: functionName, args, result, mode
func (_m *Pool) Call16Typed(functionName string, args interface{}, result interface{}, mode pool.Mode) error {
	ret := _m.Called(functionName, args, result, mode)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}, pool.Mode) error); ok {
		r0 = rf(functionName, args, result, mode)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Call17 provides a mock function with given fields: functionName, args, mode
func (_m *Pool) Call17(functionName string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	ret := _m.Called(functionName, args, mode)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) ([]interface{}, error)); ok {
		return rf(functionName, args, mode)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) []interface{}); ok {
		r0 = rf(functionName, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, pool.Mode) error); ok {
		r1 = rf(functionName, args, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Call17Async provides a mock function with given fields: functionName, args, mode
func (_m *Pool) Call17Async(functionName string, args interface{}, mode pool.Mode) *tarantool.Future {
	ret := _m.Called(functionName, args, mode)

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) *tarantool.Future); ok {
		r0 = rf(functionName, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// Call17Typed provides a mock function with given fields: functionName, args, result, mode
func (_m *Pool) Call17Typed(functionName string, args interface{}, result interface{}, mode pool.Mode) error {
	ret := _m.Called(functionName, args, result, mode)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}, pool.Mode) error); ok {
		r0 = rf(functionName, args, result, mode)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CallAsync provides a mock function with given fields: functionName, args, mode
func (_m *Pool) CallAsync(functionName string, args interface{}, mode pool.Mode) *tarantool.Future {
	ret := _m.Called(functionName, args, mode)

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) *tarantool.Future); ok {
		r0 = rf(functionName, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// CallTyped provides a mock function with given fields: functionName, args, result, mode
func (_m *Pool) CallTyped(functionName string, args interface{}, result interface{}, mode pool.Mode) error {
	ret := _m.Called(functionName, args, result, mode)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}, pool.Mode) error); ok {
		r0 = rf(functionName, args, result, mode)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Close provides a mock function with given fields:
func (_m *Pool) Close() []error {
	ret := _m.Called()

	var r0 []error
	if rf, ok := ret.Get(0).(func() []error); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]error)
		}
	}

	return r0
}

// CloseGraceful provides a mock function with given fields:
func (_m *Pool) CloseGraceful() []error {
	ret := _m.Called()

	var r0 []error
	if rf, ok := ret.Get(0).(func() []error); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]error)
		}
	}

	return r0
}

// ConfiguredTimeout provides a mock function with given fields: mode
func (_m *Pool) ConfiguredTimeout(mode pool.Mode) (time.Duration, error) {
	ret := _m.Called(mode)

	var r0 time.Duration
	var r1 error
	if rf, ok := ret.Get(0).(func(pool.Mode) (time.Duration, error)); ok {
		return rf(mode)
	}
	if rf, ok := ret.Get(0).(func(pool.Mode) time.Duration); ok {
		r0 = rf(mode)
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	if rf, ok := ret.Get(1).(func(pool.Mode) error); ok {
		r1 = rf(mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConnectedNow provides a mock function with given fields: mode
func (_m *Pool) ConnectedNow(mode pool.Mode) (bool, error) {
	ret := _m.Called(mode)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(pool.Mode) (bool, error)); ok {
		return rf(mode)
	}
	if rf, ok := ret.Get(0).(func(pool.Mode) bool); ok {
		r0 = rf(mode)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(pool.Mode) error); ok {
		r1 = rf(mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: space, index, key, mode
func (_m *Pool) Delete(space interface{}, index interface{}, key interface{}, mode ...pool.Mode) ([]interface{}, error) {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, ...pool.Mode) ([]interface{}, error)); ok {
		return rf(space, index, key, mode...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, ...pool.Mode) []interface{}); ok {
		r0 = rf(space, index, key, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, interface{}, ...pool.Mode) error); ok {
		r1 = rf(space, index, key, mode...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAsync provides a mock function with given fields: space, index, key, mode
func (_m *Pool) DeleteAsync(space interface{}, index interface{}, key interface{}, mode ...pool.Mode) *tarantool.Future {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, ...pool.Mode) *tarantool.Future); ok {
		r0 = rf(space, index, key, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// DeleteTyped provides a mock function with given fields: space, index, key, result, mode
func (_m *Pool) DeleteTyped(space interface{}, index interface{}, key interface{}, result interface{}, mode ...pool.Mode) error {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key, result)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, interface{}, ...pool.Mode) error); ok {
		r0 = rf(space, index, key, result, mode...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Do provides a mock function with given fields: req, mode
func (_m *Pool) Do(req tarantool.Request, mode pool.Mode) *tarantool.Future {
	ret := _m.Called(req, mode)

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(tarantool.Request, pool.Mode) *tarantool.Future); ok {
		r0 = rf(req, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// Eval provides a mock function with given fields: expr, args, mode
func (_m *Pool) Eval(expr string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	ret := _m.Called(expr, args, mode)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) ([]interface{}, error)); ok {
		return rf(expr, args, mode)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) []interface{}); ok {
		r0 = rf(expr, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, pool.Mode) error); ok {
		r1 = rf(expr, args, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvalAsync provides a mock function with given fields: expr, args, mode
func (_m *Pool) EvalAsync(expr string, args interface{}, mode pool.Mode) *tarantool.Future {
	ret := _m.Called(expr, args, mode)

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) *tarantool.Future); ok {
		r0 = rf(expr, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// EvalTyped provides a mock function with given fields: expr, args, result, mode
func (_m *Pool) EvalTyped(expr string, args interface{}, result interface{}, mode pool.Mode) error {
	ret := _m.Called(expr, args, result, mode)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}, pool.Mode) error); ok {
		r0 = rf(expr, args, result, mode)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Execute provides a mock function with given fields: expr, args, mode
func (_m *Pool) Execute(expr string, args interface{}, mode pool.Mode) ([]interface{}, error) {
	ret := _m.Called(expr, args, mode)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) ([]interface{}, error)); ok {
		return rf(expr, args, mode)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) []interface{}); ok {
		r0 = rf(expr, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, pool.Mode) error); ok {
		r1 = rf(expr, args, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecuteAsync provides a mock function with given fields: expr, args, mode
func (_m *Pool) ExecuteAsync(expr string, args interface{}, mode pool.Mode) *tarantool.Future {
	ret := _m.Called(expr, args, mode)

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(string, interface{}, pool.Mode) *tarantool.Future); ok {
		r0 = rf(expr, args, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// ExecuteTyped provides a mock function with given fields: expr, args, result, mode
func (_m *Pool) ExecuteTyped(expr string, args interface{}, result interface{}, mode pool.Mode) (tarantool.SQLInfo, []tarantool.ColumnMetaData, error) {
	ret := _m.Called(expr, args, result, mode)

	var r0 tarantool.SQLInfo
	var r1 []tarantool.ColumnMetaData
	var r2 error
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}, pool.Mode) (tarantool.SQLInfo, []tarantool.ColumnMetaData, error)); ok {
		return rf(expr, args, result, mode)
	}
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}, pool.Mode) tarantool.SQLInfo); ok {
		r0 = rf(expr, args, result, mode)
	} else {
		r0 = ret.Get(0).(tarantool.SQLInfo)
	}

	if rf, ok := ret.Get(1).(func(string, interface{}, interface{}, pool.Mode) []tarantool.ColumnMetaData); ok {
		r1 = rf(expr, args, result, mode)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]tarantool.ColumnMetaData)
		}
	}

	if rf, ok := ret.Get(2).(func(string, interface{}, interface{}, pool.Mode) error); ok {
		r2 = rf(expr, args, result, mode)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTyped provides a mock function with given fields: space, index, key, result, mode
func (_m *Pool) GetTyped(space interface{}, index interface{}, key interface{}, result interface{}, mode ...pool.Mode) error {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key, result)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, interface{}, ...pool.Mode) error); ok {
		r0 = rf(space, index, key, result, mode...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Insert provides a mock function with given fields: space, tuple, mode
func (_m *Pool) Insert(space interface{}, tuple interface{}, mode ...pool.Mode) ([]interface{}, error) {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...pool.Mode) ([]interface{}, error)); ok {
		return rf(space, tuple, mode...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...pool.Mode) []interface{}); ok {
		r0 = rf(space, tuple, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, ...pool.Mode) error); ok {
		r1 = rf(space, tuple, mode...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertAsync provides a mock function with given fields: space, tuple, mode
func (_m *Pool) InsertAsync(space interface{}, tuple interface{}, mode ...pool.Mode) *tarantool.Future {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...pool.Mode) *tarantool.Future); ok {
		r0 = rf(space, tuple, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// InsertTyped provides a mock function with given fields: space, tuple, result, mode
func (_m *Pool) InsertTyped(space interface{}, tuple interface{}, result interface{}, mode ...pool.Mode) error {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple, result)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, ...pool.Mode) error); ok {
		r0 = rf(space, tuple, result, mode...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewPrepared provides a mock function with given fields: expr, mode
func (_m *Pool) NewPrepared(expr string, mode pool.Mode) (*tarantool.Prepared, error) {
	ret := _m.Called(expr, mode)

	var r0 *tarantool.Prepared
	var r1 error
	if rf, ok := ret.Get(0).(func(string, pool.Mode) (*tarantool.Prepared, error)); ok {
		return rf(expr, mode)
	}
	if rf, ok := ret.Get(0).(func(string, pool.Mode) *tarantool.Prepared); ok {
		r0 = rf(expr, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Prepared)
		}
	}

	if rf, ok := ret.Get(1).(func(string, pool.Mode) error); ok {
		r1 = rf(expr, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewStream provides a mock function with given fields: mode
func (_m *Pool) NewStream(mode pool.Mode) (*tarantool.Stream, error) {
	ret := _m.Called(mode)

	var r0 *tarantool.Stream
	var r1 error
	if rf, ok := ret.Get(0).(func(pool.Mode) (*tarantool.Stream, error)); ok {
		return rf(mode)
	}
	if rf, ok := ret.Get(0).(func(pool.Mode) *tarantool.Stream); ok {
		r0 = rf(mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Stream)
		}
	}

	if rf, ok := ret.Get(1).(func(pool.Mode) error); ok {
		r1 = rf(mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewWatcher provides a mock function with given fields: key, callback, mode
func (_m *Pool) NewWatcher(key string, callback tarantool.WatchCallback, mode pool.Mode) (tarantool.Watcher, error) {
	ret := _m.Called(key, callback, mode)

	var r0 tarantool.Watcher
	var r1 error
	if rf, ok := ret.Get(0).(func(string, tarantool.WatchCallback, pool.Mode) (tarantool.Watcher, error)); ok {
		return rf(key, callback, mode)
	}
	if rf, ok := ret.Get(0).(func(string, tarantool.WatchCallback, pool.Mode) tarantool.Watcher); ok {
		r0 = rf(key, callback, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(tarantool.Watcher)
		}
	}

	if rf, ok := ret.Get(1).(func(string, tarantool.WatchCallback, pool.Mode) error); ok {
		r1 = rf(key, callback, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Ping provides a mock function with given fields: mode
func (_m *Pool) Ping(mode pool.Mode) ([]interface{}, error) {
	ret := _m.Called(mode)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(pool.Mode) ([]interface{}, error)); ok {
		return rf(mode)
	}
	if rf, ok := ret.Get(0).(func(pool.Mode) []interface{}); ok {
		r0 = rf(mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(pool.Mode) error); ok {
		r1 = rf(mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Remove provides a mock function with given fields: name
func (_m *Pool) Remove(name string) error {
	ret := _m.Called(name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Replace provides a mock function with given fields: space, tuple, mode
func (_m *Pool) Replace(space interface{}, tuple interface{}, mode ...pool.Mode) ([]interface{}, error) {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...pool.Mode) ([]interface{}, error)); ok {
		return rf(space, tuple, mode...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...pool.Mode) []interface{}); ok {
		r0 = rf(space, tuple, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, ...pool.Mode) error); ok {
		r1 = rf(space, tuple, mode...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceAsync provides a mock function with given fields: space, tuple, mode
func (_m *Pool) ReplaceAsync(space interface{}, tuple interface{}, mode ...pool.Mode) *tarantool.Future {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...pool.Mode) *tarantool.Future); ok {
		r0 = rf(space, tuple, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// ReplaceTyped provides a mock function with given fields: space, tuple, result, mode
func (_m *Pool) ReplaceTyped(space interface{}, tuple interface{}, result interface{}, mode ...pool.Mode) error {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple, result)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, ...pool.Mode) error); ok {
		r0 = rf(space, tuple, result, mode...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Select provides a mock function with given fields: space, index, offset, limit, iterator, key, mode
func (_m *Pool) Select(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, mode ...pool.Mode) ([]interface{}, error) {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, offset, limit, iterator, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, uint32, uint32, tarantool.Iter, interface{}, ...pool.Mode) ([]interface{}, error)); ok {
		return rf(space, index, offset, limit, iterator, key, mode...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, uint32, uint32, tarantool.Iter, interface{}, ...pool.Mode) []interface{}); ok {
		r0 = rf(space, index, offset, limit, iterator, key, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, uint32, uint32, tarantool.Iter, interface{}, ...pool.Mode) error); ok {
		r1 = rf(space, index, offset, limit, iterator, key, mode...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SelectAsync provides a mock function with given fields: space, index, offset, limit, iterator, key, mode
func (_m *Pool) SelectAsync(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, mode ...pool.Mode) *tarantool.Future {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, offset, limit, iterator, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, uint32, uint32, tarantool.Iter, interface{}, ...pool.Mode) *tarantool.Future); ok {
		r0 = rf(space, index, offset, limit, iterator, key, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// SelectTyped provides a mock function with given fields: space, index, offset, limit, iterator, key, result, mode
func (_m *Pool) SelectTyped(space interface{}, index interface{}, offset uint32, limit uint32, iterator tarantool.Iter, key interface{}, result interface{}, mode ...pool.Mode) error {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, offset, limit, iterator, key, result)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, uint32, uint32, tarantool.Iter, interface{}, interface{}, ...pool.Mode) error); ok {
		r0 = rf(space, index, offset, limit, iterator, key, result, mode...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Update provides a mock function with given fields: space, index, key, ops, mode
func (_m *Pool) Update(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, mode ...pool.Mode) ([]interface{}, error) {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key, ops)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, *tarantool.Operations, ...pool.Mode) ([]interface{}, error)); ok {
		return rf(space, index, key, ops, mode...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, *tarantool.Operations, ...pool.Mode) []interface{}); ok {
		r0 = rf(space, index, key, ops, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, interface{}, *tarantool.Operations, ...pool.Mode) error); ok {
		r1 = rf(space, index, key, ops, mode...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAsync provides a mock function with given fields: space, index, key, ops, mode
func (_m *Pool) UpdateAsync(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, mode ...pool.Mode) *tarantool.Future {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key, ops)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, *tarantool.Operations, ...pool.Mode) *tarantool.Future); ok {
		r0 = rf(space, index, key, ops, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// UpdateTyped provides a mock function with given fields: space, index, key, ops, result, mode
func (_m *Pool) UpdateTyped(space interface{}, index interface{}, key interface{}, ops *tarantool.Operations, result interface{}, mode ...pool.Mode) error {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, index, key, ops, result)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}, *tarantool.Operations, interface{}, ...pool.Mode) error); ok {
		r0 = rf(space, index, key, ops, result, mode...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Upsert provides a mock function with given fields: space, tuple, ops, mode
func (_m *Pool) Upsert(space interface{}, tuple interface{}, ops *tarantool.Operations, mode ...pool.Mode) ([]interface{}, error) {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple, ops)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, *tarantool.Operations, ...pool.Mode) ([]interface{}, error)); ok {
		return rf(space, tuple, ops, mode...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, *tarantool.Operations, ...pool.Mode) []interface{}); ok {
		r0 = rf(space, tuple, ops, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, *tarantool.Operations, ...pool.Mode) error); ok {
		r1 = rf(space, tuple, ops, mode...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertAsync provides a mock function with given fields: space, tuple, ops, mode
func (_m *Pool) UpsertAsync(space interface{}, tuple interface{}, ops *tarantool.Operations, mode ...pool.Mode) *tarantool.Future {
	_va := make([]interface{}, len(mode))
	for _i := range mode {
		_va[_i] = mode[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, space, tuple, ops)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *tarantool.Future
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, *tarantool.Operations, ...pool.Mode) *tarantool.Future); ok {
		r0 = rf(space, tuple, ops, mode...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*tarantool.Future)
		}
	}

	return r0
}

// NewPool creates a new instance of Pool. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPool(t interface {
	mock.TestingT
	Cleanup(func())
}) *Pool {
	mock := &Pool{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
